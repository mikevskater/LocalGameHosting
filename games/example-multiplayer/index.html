<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiplayer Drawing</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #2c3e50;
      color: white;
      overflow: hidden;
      height: 100vh;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    .main-area {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .canvas-header {
      background: #34495e;
      padding: 15px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      z-index: 10;
    }

    .canvas-wrapper {
      flex: 1;
      position: relative;
      background: white;
      overflow: hidden;
    }

    #drawing-canvas {
      display: block;
      cursor: crosshair;
      background: white;
      width: 100%;
      height: 100%;
    }

    .cursor {
      position: absolute;
      pointer-events: none;
      z-index: 100;
      transition: all 0.05s linear;
    }

    .cursor-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .cursor-label {
      position: absolute;
      top: -25px;
      left: 25px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .sidebar {
      width: 300px;
      background: #34495e;
      display: flex;
      flex-direction: column;
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
    }

    .panel {
      padding: 15px;
      border-bottom: 1px solid #2c3e50;
    }

    .panel h2 {
      margin-bottom: 12px;
      font-size: 1rem;
      color: #ecf0f1;
      border-bottom: 2px solid #2ecc71;
      padding-bottom: 8px;
    }

    .player-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 200px;
      overflow-y: auto;
    }

    .player-item {
      padding: 8px;
      background: #2c3e50;
      border-radius: 6px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.9rem;
    }

    .player-color {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid white;
      flex-shrink: 0;
    }

    .chat-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .chat-message {
      display: flex;
      gap: 10px;
      animation: slideIn 0.2s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .chat-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 0.9rem;
      color: white;
      border: 2px solid white;
    }

    .chat-content {
      flex: 1;
      min-width: 0;
    }

    .chat-header {
      display: flex;
      gap: 8px;
      align-items: baseline;
      margin-bottom: 4px;
    }

    .chat-name {
      font-weight: bold;
      font-size: 0.9rem;
    }

    .chat-time {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .chat-text {
      font-size: 0.9rem;
      word-wrap: break-word;
      color: #ecf0f1;
    }

    .chat-input-area {
      padding: 10px;
      background: #2c3e50;
      border-top: 1px solid #1a252f;
    }

    .chat-input {
      width: 100%;
      padding: 10px;
      border: none;
      border-radius: 6px;
      background: #34495e;
      color: white;
      font-size: 0.9rem;
      resize: none;
    }

    .chat-input:focus {
      outline: 2px solid #2ecc71;
    }

    .color-btn {
      width: 36px;
      height: 36px;
      border: 3px solid transparent;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .color-btn:hover {
      transform: scale(1.1);
    }

    .color-btn.active {
      border-color: white;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.9rem;
    }

    .btn-clear {
      background: #e74c3c;
      color: white;
    }

    .btn-clear:hover {
      background: #c0392b;
    }

    .brush-size {
      width: 100px;
    }

    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        max-height: 40vh;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Main Canvas Area -->
    <div class="main-area">
      <div class="canvas-header">
        <button class="color-btn active" style="background: black;" data-color="#000000"></button>
        <button class="color-btn" style="background: #e74c3c;" data-color="#e74c3c"></button>
        <button class="color-btn" style="background: #3498db;" data-color="#3498db"></button>
        <button class="color-btn" style="background: #2ecc71;" data-color="#2ecc71"></button>
        <button class="color-btn" style="background: #f39c12;" data-color="#f39c12"></button>
        <button class="color-btn" style="background: #9b59b6;" data-color="#9b59b6"></button>
        <button class="color-btn" style="background: white; border-color: #bdc3c7;" data-color="#ffffff"></button>
        <label style="margin-left: 10px; display: flex; align-items: center; gap: 10px;">
          <span>Size:</span>
          <input type="range" class="brush-size" min="1" max="20" value="3" id="brush-size">
        </label>
        <button class="btn btn-clear" onclick="clearCanvas()">Clear Canvas</button>
      </div>

      <div class="canvas-wrapper" id="canvas-wrapper">
        <canvas id="drawing-canvas"></canvas>
        <!-- Cursors will be inserted here -->
      </div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar">
      <div class="panel">
        <h2>Connected Players (<span id="player-count">0</span>)</h2>
        <div id="player-list" class="player-list">
          <p style="text-align: center; opacity: 0.7; font-size: 0.9rem;">Loading...</p>
        </div>
      </div>

      <div class="panel chat-panel">
        <h2>Chat</h2>
        <div class="chat-messages" id="chat-messages">
          <!-- Messages will be inserted here -->
        </div>
        <div class="chat-input-area">
          <textarea class="chat-input" id="chat-input" placeholder="Type a message..." rows="2"></textarea>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Canvas setup
    const canvas = document.getElementById('drawing-canvas');
    const ctx = canvas.getContext('2d');
    const canvasWrapper = document.getElementById('canvas-wrapper');
    let isDrawing = false;
    let currentColor = '#000000';
    let brushSize = 3;
    let lastX = 0;
    let lastY = 0;
    let currentUser = null;
    let connectedPlayers = new Map();
    let playerCursors = new Map();
    let canvasHistory = []; // Store drawing history for new users

    // Resize canvas to fill wrapper
    function resizeCanvas() {
      const rect = canvasWrapper.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;

      // Redraw from history after resize
      redrawCanvas();
    }

    window.addEventListener('resize', resizeCanvas);

    // Setup color buttons
    document.querySelectorAll('.color-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentColor = btn.dataset.color;
      });
    });

    // Brush size
    document.getElementById('brush-size').addEventListener('input', (e) => {
      brushSize = parseInt(e.target.value);
    });

    // Drawing functions
    function getCanvasCoordinates(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      let clientX, clientY;
      if (e.touches && e.touches[0]) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }

    function startDrawing(e) {
      isDrawing = true;
      const coords = getCanvasCoordinates(e);
      lastX = coords.x;
      lastY = coords.y;
    }

    function draw(e) {
      if (!isDrawing) return;
      e.preventDefault();

      const coords = getCanvasCoordinates(e);
      const x = coords.x;
      const y = coords.y;

      drawLine(lastX, lastY, x, y, currentColor, brushSize);

      // Add to history
      const drawData = {
        x1: lastX,
        y1: lastY,
        x2: x,
        y2: y,
        color: currentColor,
        size: brushSize
      };
      canvasHistory.push(drawData);

      // Broadcast to other players
      gameAPI.emit('draw', drawData);

      lastX = x;
      lastY = y;
    }

    function stopDrawing() {
      isDrawing = false;
    }

    function drawLine(x1, y1, x2, y2, color, size) {
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = size;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    function redrawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      canvasHistory.forEach(data => {
        drawLine(data.x1, data.y1, data.x2, data.y2, data.color, data.size);
      });
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      canvasHistory = [];
      gameAPI.emit('clear-canvas', {});
    }

    // Mouse/touch events
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      startDrawing(e);
    });
    canvas.addEventListener('touchmove', draw);
    canvas.addEventListener('touchend', stopDrawing);

    // Cursor tracking
    canvas.addEventListener('mousemove', (e) => {
      const coords = getCanvasCoordinates(e);
      const rect = canvas.getBoundingClientRect();

      gameAPI.emit('cursor-move', {
        x: coords.x,
        y: coords.y,
        canvasWidth: canvas.width,
        canvasHeight: canvas.height
      });
    });

    // Create or update cursor for a player
    function updatePlayerCursor(userId, data, user) {
      let cursorEl = playerCursors.get(userId);

      if (!cursorEl) {
        cursorEl = document.createElement('div');
        cursorEl.className = 'cursor';
        cursorEl.innerHTML = `
          <div class="cursor-dot" style="background: ${user.playerColor}"></div>
          <div class="cursor-label" style="color: ${user.nameColor}">${user.nickname}</div>
        `;
        canvasWrapper.appendChild(cursorEl);
        playerCursors.set(userId, cursorEl);
      }

      // Scale position to current canvas size
      const rect = canvas.getBoundingClientRect();
      const scaleX = rect.width / data.canvasWidth;
      const scaleY = rect.height / data.canvasHeight;

      const displayX = data.x * scaleX;
      const displayY = data.y * scaleY;

      cursorEl.style.left = displayX + 'px';
      cursorEl.style.top = displayY + 'px';
      cursorEl.style.display = 'block';
    }

    function removePlayerCursor(userId) {
      const cursorEl = playerCursors.get(userId);
      if (cursorEl) {
        cursorEl.remove();
        playerCursors.delete(userId);
      }
    }

    // Chat functions
    function addChatMessage(user, message, timestamp) {
      const messagesContainer = document.getElementById('chat-messages');
      const messageEl = document.createElement('div');
      messageEl.className = 'chat-message';

      const time = new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const initial = user.nickname.charAt(0).toUpperCase();

      messageEl.innerHTML = `
        <div class="chat-avatar" style="background: ${user.playerColor}">
          ${initial}
        </div>
        <div class="chat-content">
          <div class="chat-header">
            <span class="chat-name" style="color: ${user.nameColor}">${user.nickname}</span>
            <span class="chat-time">${time}</span>
          </div>
          <div class="chat-text">${escapeHtml(message)}</div>
        </div>
      `;

      messagesContainer.appendChild(messageEl);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Chat input handler
    document.getElementById('chat-input').addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        const input = e.target;
        const message = input.value.trim();

        if (message) {
          gameAPI.emit('chat-message', {
            message: message,
            timestamp: Date.now()
          });

          // Add own message to chat
          addChatMessage(currentUser, message, Date.now());
          input.value = '';
        }
      }
    });

    // Socket.IO events
    gameAPI.on('draw', (data, user) => {
      drawLine(data.x1, data.y1, data.x2, data.y2, data.color, data.size);
      canvasHistory.push(data);
    });

    gameAPI.on('clear-canvas', () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      canvasHistory = [];
    });

    gameAPI.on('cursor-move', (data, user) => {
      updatePlayerCursor(user.id, data, user);
    });

    gameAPI.on('chat-message', (data, user) => {
      addChatMessage(user, data.message, data.timestamp);
    });

    gameAPI.on('request-canvas-state', (data, user) => {
      // Send canvas history to new user
      if (canvasHistory.length > 0) {
        gameAPI.emitTo(user.id, 'canvas-state', { history: canvasHistory });
      }
    });

    gameAPI.on('canvas-state', (data) => {
      // Receive canvas history
      canvasHistory = data.history;
      redrawCanvas();
    });

    gameAPI.on('user-connected', (user) => {
      connectedPlayers.set(user.id, user);
      updatePlayerList();

      // System message
      addChatMessage(
        { nickname: 'System', nameColor: '#95a5a6', playerColor: '#7f8c8d' },
        `${user.nickname} joined the room`,
        Date.now()
      );
    });

    gameAPI.on('user-disconnected', (user) => {
      connectedPlayers.delete(user.id);
      removePlayerCursor(user.id);
      updatePlayerList();

      // System message
      addChatMessage(
        { nickname: 'System', nameColor: '#95a5a6', playerColor: '#7f8c8d' },
        `${user.nickname} left the room`,
        Date.now()
      );
    });

    // Update player list
    async function updatePlayerList() {
      const players = await gameAPI.getConnectedUsers();
      const playerList = document.getElementById('player-list');
      const playerCount = document.getElementById('player-count');

      playerCount.textContent = players.length;

      if (players.length === 0) {
        playerList.innerHTML = '<p style="text-align: center; opacity: 0.7; font-size: 0.9rem;">Just you</p>';
        return;
      }

      playerList.innerHTML = players.map(player => `
        <div class="player-item">
          <div class="player-color" style="background: ${player.playerColor}"></div>
          <span style="color: ${player.nameColor}">${player.nickname}</span>
          ${player.id === currentUser.id ? '<span style="opacity: 0.7; font-size: 0.8rem;">(You)</span>' : ''}
        </div>
      `).join('');
    }

    // Initialize when page loads
    window.addEventListener('load', async () => {
      if (gameAPI && gameAPI.isAuthenticated()) {
        // Get user profile
        const profileResult = await gameAPI.getProfile();
        if (!profileResult.success) {
          window.location.href = '/';
          return;
        }

        currentUser = profileResult.user;

        resizeCanvas();
        updatePlayerList();

        // Request canvas state from other users (wait a bit for socket to connect)
        setTimeout(() => {
          gameAPI.emit('request-canvas-state', {});
        }, 500);

        // Update player list periodically
        setInterval(updatePlayerList, 5000);
      } else {
        document.body.innerHTML = `
          <div style="text-align: center; padding: 50px;">
            <h1>Not Logged In</h1>
            <p>Please <a href="/" style="color: #2ecc71;">log in</a> to play this game.</p>
          </div>
        `;
      }
    });
  </script>
</body>
</html>
